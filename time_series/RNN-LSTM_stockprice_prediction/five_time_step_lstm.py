# -*- coding: utf-8 -*-
"""Copy of 5_time_step_lstm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MsgXzCdW9fozreLfKLEIU2zHMBQvsB2R
"""

import numpy as np
import pandas as pd
from sklearn import preprocessing
 
from keras.models import Sequential
from keras.layers.core import Dense
from keras.layers.recurrent import LSTM
from keras.layers import  Dropout
 
import matplotlib.pyplot as plt

import io
from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.StringIO(uploaded['DEUBANK.csv'].decode('utf-8')), parse_dates=[0])
print(df.tail(),df.shape)

#how many data we will use 
# (should not be more than dataset length )
data_to_use= df.shape[0]
 
# number of training data
# should be less than data_to_use
train_end =int(0.99*data_to_use)
 
 
total_data=len(df)
 
#most recent data is in the end 
#so need offset
#start=total_data - data_to_use
 
 
#currently doing prediction only for 3 steps ahead
steps_to_predict = 5
train_mse=[]
test_mse=[]
forecast=[]
for i in range(steps_to_predict):
    train_mse.append(0)
    test_mse.append(0)
    forecast.append(0)
 
 
yt = df.iloc [:total_data ,4]    #Close price
yt1 = df.iloc [:total_data ,1]   #Open
yt2 = df.iloc [:total_data ,2]   #High
yt3 = df.iloc [:total_data ,3]   #Low

print(train_end,len(yt))

for i in range(steps_to_predict):
     
    if i==0:
        units=20
        batch_size=10
    if i==1:
        units=15
        batch_size=10
    if i==2:
         units=80
         batch_size=10
     
         
 
    yt_ = yt.shift (-i - 1  )   
 
    data = pd.concat ([yt, yt_, yt1, yt2, yt3], axis =1)
    data. columns = ['yt', 'yt_', 'yt1', 'yt2', 'yt3']
     
    data = data.dropna()
     
    
     
# target variable - closed price
    y = data ['yt_']
 
        
#       closed,   open,  high,   low    
    cols =['yt', 'yt1', 'yt2', 'yt3']
    x = data [cols]
 
   
    
    scaler_x = preprocessing.MinMaxScaler ( feature_range =( -1, 1))
    x = np. array (x).reshape ((len( x) ,len(cols)))
    x = scaler_x.fit_transform (x)
 
    
    scaler_y = preprocessing. MinMaxScaler ( feature_range =( -1, 1))
    y = np.array (y).reshape ((len( y), 1))
    y = scaler_y.fit_transform (y)
 
 
 
     
    x_train = x [: train_end,:]
 
 
    x_test = x[ train_end: ,:]    
    y_train = y [: train_end] 
 
 
 
    y_test = y[ train_end:]  
  
    print(len(x_train), len(x_test), len(y_train), len(y_test))
                
    if (i == 0) :     
        prediction_data=[]
        for j in range (len(y_test) - 0 ) :
               prediction_data.append (0)       
 
 
 
    x_train = x_train.reshape (x_train. shape + (1,)) 
    x_test = x_test.reshape (x_test. shape + (1,))
 
     
     
 
     
 
 
    seed =2018
    np.random.seed (seed)
     
##############
##  i=0
##############
    if i == 0 :
          fit0 = Sequential ()
          fit0.add (LSTM (  units , activation = 'tanh', inner_activation = 'hard_sigmoid' , input_shape =(len(cols), 1) ))
          fit0.add(Dropout(0.2))
          fit0.add (Dense (output_dim =1, activation = 'linear'))
          fit0.compile (loss ="mean_squared_error" , optimizer = "adam")  
    
          fit0.fit (x_train, y_train, batch_size =batch_size, nb_epoch =25, shuffle = False)
          train_mse[i] = fit0.evaluate (x_train, y_train, batch_size =batch_size)
          test_mse[i] = fit0.evaluate (x_test, y_test, batch_size =batch_size)
          pred = fit0.predict (x_test) 
          pred = scaler_y.inverse_transform (np. array (pred). reshape ((len( pred), 1)))
             # below is just fo i == 0
          for j in range (len(pred) - 0 ) :
                   prediction_data[j] = pred[j] 
                   
              
                
          forecast[i]=pred[-1]
          print(forecast)
          
                   
#############
##  i=1
#############
    if i == 1 :    
          fit1 = Sequential ()
          fit1.add (LSTM (  units , activation = 'tanh', inner_activation = 'hard_sigmoid' , input_shape =(len(cols), 1) ))
          fit1.add(Dropout(0.2))
          fit1.add (Dense (output_dim =1, activation = 'linear'))
          fit1.compile (loss ="mean_squared_error" , optimizer = "adam")  
          fit1.fit (x_train, y_train, batch_size =batch_size, nb_epoch =25, shuffle = False)
          train_mse[i] = fit1.evaluate (x_train, y_train, batch_size =batch_size)
          test_mse[i] = fit1.evaluate (x_test, y_test, batch_size =batch_size)
          pred = fit1.predict (x_test) 
          pred = scaler_y.inverse_transform (np. array (pred). reshape ((len( pred), 1)))
          forecast[i]=pred[-1]
          print(forecast)
         
           
        
#############
##  i=2
#############
    if i==2 :
          fit2 = Sequential ()
          fit2.add (LSTM (  units , activation = 'tanh', inner_activation = 'hard_sigmoid' , input_shape =(len(cols), 1) ))
          fit2.add(Dropout(0.2))
          fit2.add (Dense (output_dim =1, activation = 'linear'))
          fit2.compile (loss ="mean_squared_error" , optimizer = "adam")  
          fit2.fit (x_train, y_train, batch_size =batch_size, nb_epoch =25, shuffle = False)
          train_mse[i] = fit2.evaluate (x_train, y_train, batch_size =batch_size)
          test_mse[i] = fit2.evaluate (x_test, y_test, batch_size =batch_size)
          pred = fit2.predict (x_test) 
          pred = scaler_y.inverse_transform (np. array (pred). reshape ((len( pred), 1)))
               
          forecast[i]=pred[-1]
          print(forecast)
#############
##  i=3
#############
    if i==3 :
          fit3 = Sequential ()
          fit3.add (LSTM (  units , activation = 'tanh', inner_activation = 'hard_sigmoid' , input_shape =(len(cols), 1) ))
          fit3.add(Dropout(0.2))
          fit3.add (Dense (output_dim =1, activation = 'linear'))
          fit3.compile (loss ="mean_squared_error" , optimizer = "adam")  
          fit3.fit (x_train, y_train, batch_size =batch_size, nb_epoch =25, shuffle = False)
          train_mse[i] = fit2.evaluate (x_train, y_train, batch_size =batch_size)
          test_mse[i] = fit2.evaluate (x_test, y_test, batch_size =batch_size)
          pred = fit2.predict (x_test) 
          pred = scaler_y.inverse_transform (np. array (pred). reshape ((len( pred), 1)))
               
          forecast[i]=pred[-1]
          print(forecast)
#############
##  i=4
#############
    if i==4 :
          fit4 = Sequential ()
          fit4.add (LSTM (  units , activation = 'tanh', inner_activation = 'hard_sigmoid' , input_shape =(len(cols), 1) ))
          fit4.add(Dropout(0.2))
          fit4.add (Dense (output_dim =1, activation = 'linear'))
          fit4.compile (loss ="mean_squared_error" , optimizer = "adam")  
          fit4.fit (x_train, y_train, batch_size =batch_size, nb_epoch =25, shuffle = False)
          train_mse[i] = fit2.evaluate (x_train, y_train, batch_size =batch_size)
          test_mse[i] = fit2.evaluate (x_test, y_test, batch_size =batch_size)
          pred = fit2.predict (x_test) 
          pred = scaler_y.inverse_transform (np. array (pred). reshape ((len( pred), 1)))
               
          forecast[i]=pred[-1]
          print(forecast)
  
 
    x_test = scaler_x.inverse_transform (np. array (x_test). reshape ((len( x_test), len(cols))))
    
prediction_data = np.asarray(prediction_data)
prediction_data = prediction_data.ravel()

for j in range (len(prediction_data) - 1 ):
    prediction_data[len(prediction_data) - j - 1  ] =  prediction_data[len(prediction_data) - 1 - j - 1]
 
 
prediction_data = np.append(prediction_data, forecast)
 
x_test_all = yt[len(yt)-len(prediction_data)-1:len(yt)-1]
x_test_all = x_test_all.ravel()                
 
plt.plot(prediction_data, label="predictions")
plt.plot(  x_test_all, label="actual")
 
plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05),
          fancybox=True, shadow=True, ncol=2)
 
import matplotlib.ticker as mtick
fmt = '$%.0f'
tick = mtick.FormatStrFormatter(fmt)
ax = plt.axes()
ax.yaxis.set_major_formatter(tick)
 
 
plt.show()
 
print(prediction_data.shape, y_train.shape)
print ("prediction data")
print ((prediction_data))
 
print ("x_test_all")
print ((x_test_all))
 
print ("train_mse")
print (train_mse)
 
print ("test_mse")
print (test_mse)

prediction_data=prediction_data. reshape ((len( prediction_data), 1))
print(prediction_data.shape)
m=np.concatenate((y_train, prediction_data),axis=0)
print(m.shape)

m=m. reshape ((len( m), ))
df.loc[:,'predicted']=pd.Series(m)
print(df.tail(10))
print(forecast)

for x in range(len(forecast)): 
    print (forecast[x])

